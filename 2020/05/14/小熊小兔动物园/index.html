<!DOCTYPE html>
<html lang="en">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Wang chuan">
  <meta name="keywords" content="">
  <title>JavaScript 基础 - 小熊小兔动物园</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Fluid</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              Home</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">
              <i class="iconfont icon-archive-fill"></i>
              Archives</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">
              <i class="iconfont icon-category-fill"></i>
              Categories</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">
              <i class="iconfont icon-tags-fill"></i>
              Tags</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-05-14 16:49">
                    May 14, 2020 pm
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    14.3k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    161
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h1><h2 id="执行上下文-作用域链-闭包"><a href="#执行上下文-作用域链-闭包" class="headerlink" title="执行上下文/作用域链/闭包"></a>执行上下文/作用域链/闭包</h2><h3 id="介绍一下-JS-的执行上下文"><a href="#介绍一下-JS-的执行上下文" class="headerlink" title="介绍一下 JS 的执行上下文"></a>介绍一下 JS 的执行上下文</h3><p>Execution Context，分全局执行上下文和函数执行上下文，执行上下文栈称为 执行栈或调用栈。<br>EC 分为三块：this， 作用域链（scoped chain），变量对象（varible object）</p>
<h3 id="介绍一下-JS-的作用域链"><a href="#介绍一下-JS-的作用域链" class="headerlink" title="介绍一下 JS 的作用域链"></a>介绍一下 JS 的作用域链</h3><p>包含了函数被创建的作用域中对象的集合，称为函数的作用域链。<br>作用域就是变量与函数的可访问范围。<br>变量的访问可以从内到外逐级访问，遵循就近原则。全局不能访问局部变量，不同的局部相互之间不能直接访问彼此的变量。</p>
<h3 id="介绍一下闭包及应用场景"><a href="#介绍一下闭包及应用场景" class="headerlink" title="介绍一下闭包及应用场景"></a>介绍一下闭包及应用场景</h3><p>一个函数在调用时，内部的自由变量，要到这个函数被定义的地方去找，而非在这个函数当前被调用的地方去找。<br>这个函数连同它被定义的环境一起，构成了一个<strong>数据结构</strong>，成为闭包。</p>
<p>所有的函数的是闭包的。<br>块级作用域：</p>
<ol>
<li>块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了。</li>
<li>ES6 规定，块级作用域之中，函数声明语句的行为类似于<code>let</code>，在块级作用域之外不可引用。</li>
<li>考虑到环境导致的行为差异太大，应该<strong>避免</strong>在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。严格模式下，函数只能声明在当前作用域的顶层。</li>
<li>ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</li>
<li><code>let</code>只能出现在当前作用域的顶层，所以报错。第二种写法有大括号，所以块级作用域成立。</li>
<li>ES6 新增了<code>let</code>命令，用来声明变量。它的用法类似于<code>var</code>，但是所声明的变量，只在<code>let</code>命令所在的代码块内有效。</li>
</ol>
<h3 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h3><p>setTimeOut，</p>
<p>回调（回调可以是同步也可以是异步，回调就是 把一个函数作为参数传入的另一个函数），</p>
<p>函数防抖（维护全局纯净），</p>
<p>封装私有变量。</p>
<p>##this/call/apply/bind</p>
<h3 id="介绍一下-js-的-this"><a href="#介绍一下-js-的-this" class="headerlink" title="介绍一下 js 的 this"></a>介绍一下 js 的 this</h3><ol>
<li>对于直接调用 <code>foo</code> 来说，不管 <code>foo</code> 函数被放在了什么地方，<code>this</code> 一定是 <code>window</code></li>
<li>对于 <code>obj.foo()</code> 来说，我们只需要记住，谁调用了函数，谁就是 <code>this</code>，所以在这个场景下 <code>foo</code> 函数中的 <code>this</code> 就是 <code>obj</code> 对象</li>
<li>对于 <code>new</code> 的方式来说，<code>this</code> 被永远绑定在了 <code>c</code> 上面，不会被任何方式改变 <code>this</code>。</li>
</ol>
<p>根据箭头函数，普通函数，call/apply/bind 的不同 this 会不同，普通函数根据 直接调用，对象调用和 new 也有不同的this。</p>
<p>首先，<code>new</code> 的方式优先级最高，接下来是 <code>bind</code> 这些函数，然后是 <code>obj.foo()</code> 这种调用方式，最后是 <code>foo</code> 这种调用方式，同时，箭头函数的 <code>this</code> 一旦被绑定，就不会再被任何方式所改变。</p>
<h4 id="手写call"><a href="#手写call" class="headerlink" title="手写call"></a>手写call</h4><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.call2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">var</span> obj = obj || <span class="hljs-built_in">window</span>;
    <span class="hljs-keyword">var</span> args = [];
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;
        args.push(<span class="hljs-string">'arguments['</span> + i + <span class="hljs-string">']'</span>);
    &#125;
    obj.fn = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'obj.fn('</span>+args+<span class="hljs-string">')'</span>);
    <span class="hljs-keyword">delete</span> obj.fn;
    <span class="hljs-keyword">return</span> result;
&#125;;</code></pre>

<h4 id="手写apply"><a href="#手写apply" class="headerlink" title="手写apply"></a>手写apply</h4><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-string">'v in window'</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">arguments</span> = [].splice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//这一句是把参数转成数组，因为arguments不是数组，输出的时候容易观察</span>
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.value);
&#125;
<span class="hljs-keyword">var</span> obj = &#123;
    value: <span class="hljs-string">'v in obj'</span>
&#125;;
<span class="hljs-built_in">Function</span>.prototype.apply2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">var</span> obj = obj || <span class="hljs-built_in">window</span>;
    obj.fn = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> result;
    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) &#123;
        result = obj.fn;
    &#125;<span class="hljs-keyword">else</span> &#123;
        result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">'obj.fn('</span>+<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]+<span class="hljs-string">')'</span>);
    &#125;
    <span class="hljs-keyword">delete</span> obj.fn;
    <span class="hljs-keyword">return</span> result;
&#125;;
func.apply(obj);
<span class="hljs-comment">//[]</span>
<span class="hljs-comment">//v in obj</span>
func.apply(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-comment">//[1,2,3]</span>
<span class="hljs-comment">//v in obj</span>
func.apply2(obj);
<span class="hljs-comment">//[]</span>
<span class="hljs-comment">//v in obj</span>
func.apply2(obj, [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]);
<span class="hljs-comment">//[1,2,3]</span>
<span class="hljs-comment">//v in obj</span></code></pre>

<h4 id="手写bind"><a href="#手写bind" class="headerlink" title="手写bind"></a>手写bind</h4><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.bind2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">"function"</span>) &#123; <span class="hljs-comment">//不是函数不能调用bind方法</span>
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Function.prototype.bind - what is trying to be bound is not callable"</span>);
    &#125;
    <span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> func =  <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        that.apply(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> func ? <span class="hljs-keyword">this</span> : obj,args.concat([].splice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">0</span>))); <span class="hljs-comment">//用来判断是不是作为构造函数：this instanceof func === true是则是构造函数</span>
    &#125;;
    fNOP.prototype = <span class="hljs-keyword">this</span>.prototype; <span class="hljs-comment">//利用空函数fNOP实现继承原型链同时又不改变原函数的原型链</span>
    fbound.prototype = <span class="hljs-keyword">new</span> fNOP();
    <span class="hljs-keyword">return</span> func;
&#125;;</code></pre>

<h2 id="原型-继承"><a href="#原型-继承" class="headerlink" title="原型/继承"></a>原型/继承</h2><ol>
<li>每个对象都会在其内部初始化一个属性，就是prototype(原型)。</li>
<li>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，于是就这样一直找下去，也就是我们平时所说的原型链的概念。</li>
<li>JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</li>
</ol>
<h4 id="手写继承"><a href="#手写继承" class="headerlink" title="手写继承"></a>手写继承</h4><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">this</span>.name = <span class="hljs-string">'parent'</span>;
    <span class="hljs-keyword">this</span>.arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];
&#125;
Parent.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'say'</span>);
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">age</span>) </span>&#123;
    Parent.call(<span class="hljs-keyword">this</span>);
    <span class="hljs-keyword">this</span>.age = age;
&#125;
Child.prototype = <span class="hljs-built_in">Object</span>.create(Parent.prototype);
Child.prototype.constructor = Child;
<span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> Child(<span class="hljs-number">12</span>);
<span class="hljs-built_in">console</span>.log(c.name);
c.say();
<span class="hljs-built_in">console</span>.log(c.constructor); <span class="hljs-comment">//输出function Child(age) &#123;Parent.call(this);this.age = age;&#125;</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> Parent().constructor); <span class="hljs-comment">//输出Parent() &#123;this.name = 'parent';this.arr = [1,2,3,4];&#125;</span></code></pre>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span>(<span class="hljs-params">executor</span>) </span>&#123;
    <span class="hljs-keyword">var</span> self = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;
    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">undefined</span>;
    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">undefined</span>;


    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span>(<span class="hljs-params">value</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(self.status === <span class="hljs-string">'pending'</span>) &#123;
            self.status = <span class="hljs-string">'resolve'</span>;
            self.value = value;
        &#125;
    &#125;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span>(<span class="hljs-params">reason</span>) </span>&#123;
        <span class="hljs-keyword">if</span>(self.status === <span class="hljs-string">'pending'</span>) &#123;
            self.status = <span class="hljs-string">'rejected'</span>;
            self.reason = reason;
        &#125;
    &#125;
    executor(resolve, reject);
&#125;

<span class="hljs-built_in">Promise</span>.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">infulfilled, inrejected</span>) </span>&#123;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'resolve'</span>) &#123;
        infulfilled(<span class="hljs-keyword">this</span>.value)
    &#125;
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;
        inrejected(<span class="hljs-keyword">this</span>.reason)
    &#125;
&#125;;

<span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;
    resolve(<span class="hljs-string">'resolve'</span>);
&#125;);

p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(data);
&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(err);
&#125;);</code></pre>

<p>此外支持异步调用，捕获异常，链式调用等等还要补上一堆代码，非常复杂。</p>
<h3 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h3><ol>
<li><p>async/await是基于Promise实现的，它不能用于普通的回调函数。</p>
</li>
<li><p>async/await与Promise一样，是非阻塞的。</p>
</li>
<li><p>async/await使得异步代码看起来像同步代码，这正是它的魔力所在。</p>
</li>
<li><p>await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。</p>
</li>
</ol>
<p>优点：代码简洁，catch错误更明显直白。</p>
<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="介绍-js-的深浅拷贝"><a href="#介绍-js-的深浅拷贝" class="headerlink" title="介绍 js 的深浅拷贝"></a>介绍 js 的深浅拷贝</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><p>首先可以通过 <code>Object.assign</code> 来解决这个问题，很多人认为这个函数是用来深拷贝的。其实并不是，<code>Object.assign</code> 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝。 另外我们还可以通过展开运算符 <code>...</code> 来实现浅拷贝</p>
<p>浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，那么就又回到最开始的话题了，两者享有相同的地址。要解决这个问题，我们就得使用深拷贝了。</p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code> 来解决。</p>
<p>问题在于：</p>
<ul>
<li>会忽略 <code>undefined</code></li>
<li>会忽略 <code>symbol</code></li>
<li>不能序列化函数</li>
<li>不能解决<strong>循环引用</strong>的对象</li>
</ul>
<p>更推荐使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Flodash.com%2Fdocs%23cloneDeep">lodash 的深拷贝函数</a>。</p>
<h4 id="如何解决循环引用"><a href="#如何解决循环引用" class="headerlink" title="如何解决循环引用"></a>如何解决循环引用</h4><p>用 JSON-js 这个国际友人写的处理循环引用会报错的问题。</p>
<h2 id="事件机制-Event-Loop"><a href="#事件机制-Event-Loop" class="headerlink" title="事件机制/Event Loop"></a>事件机制/Event Loop</h2><h3 id="如何实现一个事件的发布订阅"><a href="#如何实现一个事件的发布订阅" class="headerlink" title="如何实现一个事件的发布订阅"></a>如何实现一个事件的发布订阅</h3><p>那一个简单的发布订阅模式怎么实现呢？定义一个EventEmitter类，它有以下几个元素：</p>
<ul>
<li>单例对象，维护订阅者：单例模式就是为保证不同的人实例化EventEmitter类之后，拿到的状态是同一个。</li>
<li>订阅方法：传入订阅的事件类型及回调函数，订阅事件</li>
<li>发布方法：传入发布的事件类型及参数（传给回调函数的），发布事件。发布时，会执行订阅时传入的回调函数</li>
<li>移除方法：移除订阅（监听）的回调函数</li>
</ul>
<pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;
            <span class="hljs-keyword">constructor</span>()&#123;
                <span class="hljs-comment">//单例模式</span>
                <span class="hljs-keyword">this</span>._events = <span class="hljs-keyword">this</span>._events || <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();
            &#125;
            <span class="hljs-comment">//发布（触发事件）</span>
            emit(type, ...args)&#123;
                <span class="hljs-comment">//拿到订阅者的回调函数</span>
                <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">this</span>._events.get(type);
                <span class="hljs-keyword">if</span>(!handler)&#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
                
                <span class="hljs-comment">//发布时，依次执行订阅者的回调</span>
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt; handler.length; i++)&#123;
                    handler[i].apply(<span class="hljs-keyword">this</span>, args);
                &#125;
            &#125;
            <span class="hljs-comment">//订阅（监听事件）</span>
            addListener(type, func)&#123;
                <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">this</span>._events.get(type);
                
                <span class="hljs-comment">//如果还没有同类型的订阅，新创建一个</span>
                <span class="hljs-keyword">if</span>(!handler)&#123;
                    <span class="hljs-keyword">this</span>._events.set(type, [func]);
                    <span class="hljs-keyword">return</span>;
                &#125;
                <span class="hljs-comment">//把回调函数塞入数组</span>
                handler.push(func);
            &#125;
            <span class="hljs-comment">//移除</span>
            removeListener(type, func)&#123;
                <span class="hljs-keyword">var</span> handler = <span class="hljs-keyword">this</span>._events.get(type);
                <span class="hljs-keyword">if</span>(!handler)&#123;
                    <span class="hljs-keyword">return</span>;
                &#125;
                
                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = handler.length; i&gt;<span class="hljs-number">0</span>; i--)&#123;
                    <span class="hljs-comment">//找到自己要移除的函数，匿名函数不能移除</span>
                    <span class="hljs-keyword">if</span>(handler[i] == func)&#123;
                        handler.splice(i, <span class="hljs-number">1</span>);
                    &#125;
                &#125; 
            &#125;
        &#125;</code></pre>

<p>该实现只是探究原理，异常处理之类的都没做。</p>
<h3 id="宏任务与微任务的区别"><a href="#宏任务与微任务的区别" class="headerlink" title="宏任务与微任务的区别"></a>宏任务与微任务的区别</h3><p>在挂起任务时，<code>JS 引擎</code>会将所有任务按照类别分到这两个队列中，首先在 <code>macrotask</code> 的队列（这个队列也被叫做 <code>task queue</code>）中取出第一个任务，执行完毕后取出 <code>microtask</code> 队列中的所有任务顺序执行；之后再取 <code>macrotask</code> 任务，周而复始，直至两个队列的任务都取完。</p>
<p>宏任务一般是：包括整体代码<code>script</code>，<code>setTimeout</code>，<code>setInterval</code>、<code>I/O</code>、<code>postMessage</code>、<code>MessageChannel</code>、<code>setImmediate(Node.js 环境)</code>。<br> 微任务主要是：<code>Promise</code>、<code>Object.observe</code>、<code>MutationObserver</code>。</p>
<p>顺序是：</p>
<ul>
<li>执行一个宏任务（栈中没有就从事件队列中获取）</li>
<li>执行过程中如果遇到微任务，就将它添加到微任务的任务队列中</li>
<li>宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）</li>
<li>当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染</li>
<li>渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）</li>
</ul>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。<br>在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。</p>
<h2 id="web-worker-service-worker"><a href="#web-worker-service-worker" class="headerlink" title="web worker/service worker"></a>web worker/service worker</h2><h3 id="web-worker"><a href="#web-worker" class="headerlink" title="web worker"></a>web worker</h3><p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<p>（1）<strong>同源限制</strong></p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）<strong>DOM 限制</strong></p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以<code>navigator</code>对象和<code>location</code>对象。</p>
<p>（3）<strong>通信联系</strong></p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（4）<strong>脚本限制</strong></p>
<p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（5）<strong>文件限制</strong></p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h3 id="service-worker"><a href="#service-worker" class="headerlink" title="service worker"></a>service worker</h3><p>它和 Web Worker 相比，有相同的点，也有不同的地方。</p>
<p>相同：</p>
<ol>
<li>Service Worker 工作在 worker context 中，是<strong>没有访问 DOM 的权限</strong>的，所以我们无法在 Service Worker 中获取 DOM 节点，也无法在其中操作 DOM 元素；</li>
<li>我们可以通过 <code>postMessage</code> 接口把数据传递给其他 JS 文件；</li>
<li>Service Worker 中运行的代码<strong>不会被阻塞</strong>，也不会阻塞其他页面的 JS 文件中的代码；</li>
</ol>
<p>不同的地方在于，Service Worker 是一个浏览器中的<strong>进程</strong>而不是浏览器内核下的线程，因此它在被注册安装之后，能够被在多个页面中使用，也不会因为页面的关闭而被销毁。因此，Service Worker 很适合被用与多个页面需要使用的复杂数据的计算——购买一次，全家“收益”。</p>
<p>另外有一点需要注意的是，出于对安全问题的考虑，<strong>Service Worker 只能被使用在 https 或者本地的 localhost 环境下</strong>。</p>
<h1 id="CSS-基础"><a href="#CSS-基础" class="headerlink" title="CSS 基础"></a>CSS 基础</h1><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><h3 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h3><p>在父级元素没有手动设置位置特性为relative的话相对于html框框。<br>在父级元素有手动设置位置特性为relative的话，相对于设了位置特性为relative 的这个父级框框。</p>
<h3 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h3><p>相对于原来文档流所在的位置</p>
<h3 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h3><p>相对于浏览器窗口 window</p>
<h2 id="行内块元素-块状元素"><a href="#行内块元素-块状元素" class="headerlink" title="行内块元素/块状元素"></a>行内块元素/块状元素</h2><h3 id="行内元素-inline"><a href="#行内元素-inline" class="headerlink" title="行内元素 inline"></a>行内元素 inline</h3><p>(1)设置宽高无效； （2）设置内外边距，边框等规则诡异； （3）不会自动换行。</p>
<h3 id="块元素-block"><a href="#块元素-block" class="headerlink" title="块元素 block"></a>块元素 block</h3><p>(1)能够识别宽高； (2)margin和padding的上下左右均对其有效；<br>(3)可以自动换行； (4)多个块状元素标签写在一起，默认排列方式为<strong>从上至下</strong></p>
<h3 id="行内块元素-inline-block"><a href="#行内块元素-inline-block" class="headerlink" title="行内块元素 inline-block"></a>行内块元素 inline-block</h3><p>(1)不自动换行； (2)能够识别宽高； (3)默认排列方式为从左到右<br>这在行内元素想变成块块或者块级元素想并排时很有用。</p>
<h2 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h2><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex布局是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br> flex布局的作用仅在设定<code>display:flex</code>属性的元素以及它的所有子元素上，并且子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。其中所设定的元素又称为<strong>容器</strong>（flex container），子元素称为<strong>项目</strong>（flex item）。</p>
<p>容器的设定存在两根轴，水平的主轴（main axis）和垂直的交叉轴（cross axis）。项目默认沿主轴排列。</p>
<h6 id="flex容器"><a href="#flex容器" class="headerlink" title="flex容器"></a>flex容器</h6><ul>
<li><code>flex-direction</code>：指定项目的轴方向</li>
<li><code>flex-wrap</code>：项目是否换行</li>
<li><code>flex-flow</code>：<code>flex-direction</code>和<code>flex-wrap</code>的合成形式</li>
<li><code>justify-content</code>：定义了项目在主轴上的对齐方式</li>
<li><code>align-items</code>：定义项目在交叉轴上如何对齐</li>
<li><code>align-content</code>：定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用</li>
</ul>
<h6 id="flex项目"><a href="#flex项目" class="headerlink" title="flex项目"></a>flex项目</h6><ul>
<li><code>order</code>：定义项目的排列顺序。数值越小，排列越靠前，默认为0</li>
<li><code>flex-grow</code>：定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大</li>
<li><code>flex-shrink</code>：定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</li>
<li><code>flex-basis</code>：定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</li>
<li><code>flex</code>：<code>flex-grow</code>,<code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</li>
<li><code>align-self</code>：允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性</li>
</ul>
<p>实际开发过程中，常用：</p>
<pre><code class="hljs plain">容器属性：
    display:flex&#x2F;inline-flex;
    flex-flow、justify-content、align-items
项目属性：
    flex、order、align-self</code></pre>

<h3 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h3><p>grid布局又叫网格布局，它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。</p>
<h6 id="Grid布局和Flex布局的区别"><a href="#Grid布局和Flex布局的区别" class="headerlink" title="Grid布局和Flex布局的区别"></a>Grid布局和Flex布局的区别</h6><p>grid和flex布局十分相似，但却有极大的不同。Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。</p>
<p>在二维布局里，正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线。grid布局的作用仍然在<strong>容器</strong>和<strong>项目</strong>中。</p>
<h6 id="grid容器"><a href="#grid容器" class="headerlink" title="grid容器"></a>grid容器</h6><ul>
<li><code>display: grid/inline-grid</code>：指定容器采用grid布局</li>
<li><code>grid-template-columns</code>：定义每一列的列宽</li>
<li><code>grid-template-rows</code>：定义每一行的行高</li>
<li><code>grid-row-gap</code>：设置行与行的间隔（行间距）</li>
<li><code>grid-column-gap</code>：设置列与列的间隔（列间距）</li>
<li><code>grid-gap</code>：<code>grid-row-gap</code>和<code>grid-column-gap</code>的合成简写</li>
<li><code>grid-template-areas</code>：用于定义区域</li>
<li><code>grid-auto-flow</code>：子元素的放置顺序，默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行</li>
<li><code>justify-items</code>：设置单元格内容的水平位置（左中右）</li>
<li><code>align-items</code>：设置单元格内容的垂直位置（上中下）</li>
<li><code>place-items</code>：<code>justify-items</code>和<code>align-items</code>的合成简写</li>
</ul>
<h6 id="grid项目"><a href="#grid项目" class="headerlink" title="grid项目"></a>grid项目</h6><ul>
<li><code>grid-column-start</code>：左边框所在的垂直网格线</li>
<li><code>grid-column-end</code>：右边框所在的垂直网格线</li>
<li><code>grid-row-start</code>：上边框所在的水平网格线</li>
<li><code>grid-row-end</code>：下边框所在的水平网格线</li>
<li><code>grid-column</code>：<code>grid-column-start</code>和<code>grid-column-end</code>的简写</li>
<li><code>grid-row</code>：<code>grid-row-start</code>和<code>grid-row-end</code>的简写</li>
<li><code>grid-area</code>：指定项目放在哪一个区域</li>
<li><code>justify-self</code>：设置单元格内容的水平位置（左中右）</li>
<li><code>align-self</code>：设置单元格内容的垂直位置（上中下）</li>
<li><code>place-self</code>：<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式</li>
</ul>
<p>可以看出，二维的布局跟一维有十分相似的，即一维时（flex）你只能规定一个方向（轴）而要充分考虑另外一个方向的排版，而二维则包括了两个轴，因此grid布局更加地简便。</p>
<p>在9102年的今天，grid布局并不能完全兼容所有浏览器，又或者说需要的浏览器版本较高，但它已经可以普遍兼容了，各位可以在日后的工作中考虑是否应用。</p>
<p>作者：Nice先生的狂想曲<br>链接：<a href="https://www.jianshu.com/p/33eaf65d80f8" target="_blank" rel="noopener">https://www.jianshu.com/p/33eaf65d80f8</a></p>
<h2 id="1px"><a href="#1px" class="headerlink" title="1px"></a>1px</h2><h3 id="移动端的-1px-问题"><a href="#移动端的-1px-问题" class="headerlink" title="移动端的 1px 问题"></a>移动端的 1px 问题</h3><p>viewport 分为 layout viewport, visual viewport, ideal viewport.<br>css的px并非物理px，这在 pc 转 移动端时就会出现不能成比例配对的问题。<br>(physical pixal != device independent, )<br>为了在各种分辨率设备下都有良好的阅读浏览体验，可以通过各种方法来解决这个问题，现在的做法是引入一个文件，使之帮我们解决适配问题。</p>
<h3 id="介绍一下-rem-方案和-vw-方案，分别有什么优缺点"><a href="#介绍一下-rem-方案和-vw-方案，分别有什么优缺点" class="headerlink" title="介绍一下 rem 方案和 vw 方案，分别有什么优缺点"></a>介绍一下 rem 方案和 vw 方案，分别有什么优缺点</h3><p>1<strong>rem</strong>=根元素html的font-size值。<br>但这种方案有弊端。</p>
<ol>
<li>rem在计算时很麻烦，有很多小数，这个时候大家可以试一下用less.js解决rem的小数问题；</li>
<li>和根元素font-size值强耦合，系统字体放大或缩小时，会导致布局错乱，也是通过引入 js 解决自适应。</li>
</ol>
<p><strong>vw</strong>：1% of viewport’s width<br><strong>vh</strong>：1% of viewport’s height<br>我们可以这样理解 100vw = window.innerwidth, 100vh = window.innerheight<br>在移动端我们一般都可以认为，100vw就是屏幕宽度。若使用vw布局，就不需要再像rem那样，在js中去动态设置根元素的font-size了，sass中只需要使用这个函数做转换即可。<br>百分比%是根据父元素宽度或者高度进行计算，而vw vh固定按照viewport来计算，不会受父元素宽高度影响。<br>相较之下，vw单位兼容性比rem稍差，ios8、安卓4.4及以上才完全支持。这也是为什么之前rem布局一直更流行的原因。时代在进步，硬件软件跟上来了，用vw更好，代码更存粹。</p>
<p>设置理想视口ideal viewport：</p>
<pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></code></pre>

<p>该meta标签的作用是让layout viewport的宽度等于visual viewport的宽度，同时不允许用户手动缩放，从而达到理想视口。　</p>
<pre><code class="hljs html">　meta[name="viewport"]里各参数的含义为：
 
　　width: 设置layout viewport 的宽度，为一个正整数，或字符串”width-device”。
 
　　initial-scale: 设置页面的初始缩放值，为一个数字，可以带小数。
 
　　minimum-scale: 允许用户的最小缩放值，为一个数字，可以带小数。
 
　　maximum-scale: 允许用户的最大缩放值，为一个数字，可以带小数。
 
　　height: 设置layout viewport 的高度，这个属性对我们并不重要，很少使用。
 
　　user-scalable: 是否允许用户进行缩放，值为“no”或“yes”。</code></pre>

<h2 id="重绘和回流"><a href="#重绘和回流" class="headerlink" title="重绘和回流"></a>重绘和回流</h2><p>在讨论回流与重绘之前，我们要知道：</p>
<ol>
<li>浏览器使用流式布局模型 (Flow Based Layout)。</li>
<li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了<code>Render Tree</code>。</li>
<li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面上的大小和位置，最后把节点绘制到页面上。</li>
<li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为repaint什么要避免使用<code>table</code>布局的原因之一。</li>
</ol>
<p><strong>一句话：回流（reflow）必将引起重绘（repaint），重绘不一定会引起回流。回流比重绘的代价要更高很多。</strong></p>
<p>现代浏览器会对频繁的回流或重绘操作进行优化：<br>浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<h3 id="如何避免重绘和回流"><a href="#如何避免重绘和回流" class="headerlink" title="如何避免重绘和回流"></a>如何避免重绘和回流</h3><h4 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h4><ul>
<li>避免使用<code>table</code>布局。</li>
<li>尽可能在<code>DOM</code>树的最末端改变<code>class</code>。</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上。</li>
<li>避免使用<code>CSS</code>表达式（例如：<code>calc()</code>）。</li>
</ul>
<p>####JavaScript</p>
<ul>
<li>避免频繁操作样式，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li>
<li>避免频繁操作<code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li>
<li>也可以先为元素设置<code>display: none</code>，操作结束后再把它显示出来。因为在<code>display</code>属性为<code>none</code>的元素上进行的<code>DOM</code>操作不会引发回流和重绘。</li>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<p>作者：腰花<br>链接：<a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">https://juejin.im/post/5a9923e9518825558251c96a</a></p>
<h2 id="居中-常见布局"><a href="#居中-常见布局" class="headerlink" title="居中/常见布局"></a>居中/常见布局</h2><p>第一种：浮动搭配清除浮动</p>
<p>第二种：relative 搭配 absolute</p>
<p>第三种：flex 搭配 grid</p>
<h2 id="层叠上下文-说一下z-index"><a href="#层叠上下文-说一下z-index" class="headerlink" title="层叠上下文 说一下z-index"></a>层叠上下文 说一下z-index</h2><ol>
<li><p>首先，<code>z-index</code>属性值并不是在任何元素上都有效果。它<strong>仅在</strong>定位元素（定义了<code>position</code>属性，且属性值为非<code>static</code>值的元素）上有效果。</p>
</li>
<li><p>判断元素在<code>Z轴</code>上的堆叠顺序，不仅仅是直接比较两个元素的<code>z-index</code>值的大小，这个堆叠顺序实际由元素的<strong>层叠上下文</strong>、<strong>层叠等级</strong>共同决定。（stacking context, stacking level）</p>
<ol>
<li><p>普通元素的层叠等级优先由其所在的层叠上下文决定。</p>
</li>
<li><p>层叠等级的比较只有在当前层叠上下文元素中才有意义。不同层叠上下文中比较层叠等级是没有意义的。</p>
</li>
<li><p>层叠上下文也基本上是有一些特定的CSS属性创建的，一般有3种方法：</p>
<ol>
<li><code>HTML</code>中的根元素``本身j就具有层叠上下文，称为“根层叠上下文”。</li>
<li>普通元素设置<code>position</code>属性为<strong>非</strong><code>static</code>值并设置<code>z-index</code>属性为具体数值，产生层叠上下文。</li>
<li>CSS3中的新属性也可以产生层叠上下文。</li>
</ol>
<p>作者：长安曹公子<br>链接：<a href="https://juejin.im/post/5b876f86518825431079ddd6" target="_blank" rel="noopener">https://juejin.im/post/5b876f86518825431079ddd6</a></p>
</li>
</ol>
</li>
<li><p>“层叠顺序”(stacking order)表示元素发生层叠时按照特定的顺序规则在<code>Z轴</code>上垂直显示。<strong>由此可见，前面所说的“层叠上下文”和“层叠等级”是一种概念，而这里的“层叠顺序”是一种规则。</strong></p>
</li>
</ol>
<p><strong>层叠等级</strong> (层叠水平, Stacking Level) 决定了同一个层叠上下文中元素在z轴上的显示顺序的<strong>概念</strong>.<br><strong>层叠顺序</strong> (层叠次序, 堆叠顺序, Stacking Order) 描述的是元素在同一个层叠上下文中的顺序<strong>规则</strong>.</p>
<h2 id="Saas-Less"><a href="#Saas-Less" class="headerlink" title="Saas/Less"></a>Saas/Less</h2><p>不管是Sass，还是Less，都可以视为一种基于CSS之上的高级语言，其目的是使得CSS开发更灵活和更强大，Sass的功能比Less强大,基本可以说是一种真正的编程语言了，Less则相对清晰明了,易于上手,对编译环境要求比较宽松。<br>The fact that Sass is in Ruby and Less is in JavaScript is of little consequence to most potential users.<br>现在sass蛮好的，stylus也不错，less相对差一点儿。</p>
<h1 id="框架-Vue-为主"><a href="#框架-Vue-为主" class="headerlink" title="框架 (Vue 为主)"></a>框架 (Vue 为主)</h1><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><h3 id="MVVM与MVC的区别"><a href="#MVVM与MVC的区别" class="headerlink" title="MVVM与MVC的区别"></a>MVVM与MVC的区别</h3><ul>
<li>MVC中Controller演变成MVVM中的ViewModel</li>
<li>MVVM通过数据来显示视图层而不是节点操作</li>
<li>MVVM主要解决了MVC中大量的dom操作使页面渲染性能降低,加载速度变慢,影响用户体验</li>
</ul>
<p>###viewmodel有什么好处</p>
<ul>
<li>低耦合:View可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候Model可以不变,当Model变化的时候View也可以不变。</li>
<li>可重用性: 可以把一些视图逻辑放在一个ViewModel里面,让很多View重用这段视图逻辑。</li>
<li>独立开发: 开发人员可以专注于业务逻辑和数据的开发,设计人员可以专注于页面的设计。</li>
</ul>
<p>作者：Tx丶<br>链接：<a href="https://juejin.im/post/5ceb4a2ef265da1b6f435291" target="_blank" rel="noopener">https://juejin.im/post/5ceb4a2ef265da1b6f435291</a></p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="nextTick是如何实现的"><a href="#nextTick是如何实现的" class="headerlink" title="nextTick是如何实现的"></a>nextTick是如何实现的</h3><p>尽管MVVM框架并不推荐访问DOM，但有时候确实会有这样的需求，尤其是和第三方插件进行配合的时候，免不了要进行DOM操作。而nextTick就提供了一个桥梁，确保我们操作的是更新后的DOM。</p>
<p>总结一下就是：</p>
<ol>
<li>vue用异步队列的方式来控制DOM更新和nextTick回调先后执行</li>
<li>microtask因为其高优先级特性，能确保队列中的微任务在一次事件循环前被执行完毕</li>
<li>因为兼容性问题，vue不得不做了microtask向macrotask的降级方案</li>
</ol>
<p>微任务-&gt;UI Render-&gt;下一个宏任务</p>
<h3 id="父子组件挂载时，生命周期的顺序是怎么样的"><a href="#父子组件挂载时，生命周期的顺序是怎么样的" class="headerlink" title="父子组件挂载时，生命周期的顺序是怎么样的"></a>父子组件挂载时，生命周期的顺序是怎么样的</h3><p>父组件先创建，然后子组件创建；子组件先挂载，然后父组件挂载。</p>
<pre><code class="hljs plain">父beforeCreate-&gt; 父create -&gt; 子beforeCreate-&gt; 子created -&gt; 子mounted -&gt; 父mounted</code></pre>

<p>子组件挂载完成后，父组件还未挂载。所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。</p>
<p><a href="https://segmentfault.com/a/1190000015890245" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015890245</a></p>
<h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="Vue的双向绑定是如何实现的"><a href="#Vue的双向绑定是如何实现的" class="headerlink" title="Vue的双向绑定是如何实现的"></a>Vue的双向绑定是如何实现的</h3><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><ul>
<li>语法</li>
</ul>
<p>Object.defineProperty(obj,prop,descriptor)</p>
<p>当我们访问或设置对象的属性的时候，都会触发相对应的函数，然后在这个函数里返回或设置属性的值。既然如此，我们当然可以在触发函数的时候动一些手脚做点我们自己想做的事情，这也就是“劫持”操作。在Vue中其实就是通过Object.defineProperty来劫持对象属性的setter和getter操作，并“种下”一个监听器，当数据发生变化的时候发出通知。<br>可以：监听对象属性的变化。监听数组的变化。实现对象属性代理。</p>
<p><a href="https://juejin.im/entry/589ff26486b599006b3dea9b" target="_blank" rel="noopener">https://juejin.im/entry/589ff26486b599006b3dea9b</a></p>
<h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><ol>
<li>发布函数，发布的时候执行相应的回调</li>
<li>订阅函数，添加订阅者,传入发布时要执行的函数,可能会携额外参数</li>
<li>一个缓存订阅者以及订阅者的回调函数的列表</li>
<li>取消订阅(需要分情况讨论)</li>
</ol>
<p>这么看下来,其实就像 <code>JavaScript</code> 中的事件模型,我们在DOM节点上绑定事件函数,触发的时候执行就是应用了发布-订阅模式.</p>
<p>当然,发布-订阅模式也是有缺点的.</p>
<ol>
<li>创建订阅者本身会消耗内存,订阅消息后,也许,永远也不会有发布,而订阅者始终存在内存中.</li>
<li>对象之间解耦的同时,他们的关系也会被深埋在代码背后,这会造成一定的维护成本.</li>
</ol>
<p>作者：薄荷前端<br>链接：<a href="https://juejin.im/post/5b29b5dff265da59615bff61" target="_blank" rel="noopener">https://juejin.im/post/5b29b5dff265da59615bff61</a></p>
<h3 id="Vue2-中关于数组和对象观察时有做什么特殊处理吗"><a href="#Vue2-中关于数组和对象观察时有做什么特殊处理吗" class="headerlink" title="Vue2 中关于数组和对象观察时有做什么特殊处理吗"></a>Vue2 中关于数组和对象观察时有做什么特殊处理吗</h3><h3 id="defineProperty-和-proxy-有什么区别"><a href="#defineProperty-和-proxy-有什么区别" class="headerlink" title="defineProperty 和 proxy 有什么区别"></a>defineProperty 和 proxy 有什么区别</h3><p>使用 defineProperty 只能重定义属性的读取（get）和设置（set）行为，到了 ES6，提供了 Proxy，可以重定义更多的行为，比如 in、delete、函数调用等更多行为。</p>
<p>Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。</p>
<pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler);</code></pre>

<p>proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。除了 get 和 set 之外，proxy 可以拦截多达 13 种操作。</p>
<p>作者：冴羽<br>链接：<a href="https://juejin.im/post/5be4f7cfe51d453339084530" target="_blank" rel="noopener">https://juejin.im/post/5be4f7cfe51d453339084530</a></p>
<h3 id="Vue中的数据为什么频繁变化但只会更新一次"><a href="#Vue中的数据为什么频繁变化但只会更新一次" class="headerlink" title="Vue中的数据为什么频繁变化但只会更新一次"></a>Vue中的数据为什么频繁变化但只会更新一次</h3><p>这是因为vue的dom更新是一个异步操作，在数据更新后会首先被<code>set</code>钩子监听到，但是不会马上执行dom更新，而是在<code>下一轮循环</code>中执行更新。 具体实现是vue中实现了一个<code>queue</code>队列用于存放本次<code>事件循环</code>中的所有<code>watcher</code>更新，并且同一个<code>watcher</code>的更新只会被推入队列一次，并在本轮事件循环的<code>微任务</code>执行结束后执行此更新(<code>UI Render</code>阶段)，这就是dom只会更新一次的原因。</p>
<p>作者：wdBly周维<br>链接：<a href="https://juejin.im/post/5d848e04e51d453b373b4ddc" target="_blank" rel="noopener">https://juejin.im/post/5d848e04e51d453b373b4ddc</a></p>
<h2 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h2><h3 id="什么是状态管理，为什么需要状态管理"><a href="#什么是状态管理，为什么需要状态管理" class="headerlink" title="什么是状态管理，为什么需要状态管理"></a>什么是状态管理，为什么需要状态管理</h3><p>状态管理库中所谓的<em>状态</em>，即驱动应用的数据源。之所以需要这类状态管理库，是为了<em>更方便组件间的通信</em>。无论组件的层级关系是祖父与孙子、曾祖父与曾孙子，只需要 connect 即可获取数据，和更新数据的方法，而不用层层传递。</p>
<h3 id="介绍一下vuex"><a href="#介绍一下vuex" class="headerlink" title="介绍一下vuex"></a>介绍一下vuex</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<h3 id="vuex-和-redux区别"><a href="#vuex-和-redux区别" class="headerlink" title="vuex 和 redux区别"></a>vuex 和 redux区别</h3><p>vuex的流向：<br>view——&gt;commit——&gt;mutations——&gt;state变化——&gt;view变化（同步操作）<br>view——&gt;dispatch——&gt;actions——&gt;mutations——&gt;state变化——&gt;view变化（异步操作）</p>
<p>redux的流向：<br>view——&gt;actions——&gt;reducer——&gt;state变化——&gt;view变化（同步异步一样）</p>
<p>Vuex相对于Redux的不同点有:<br>（1）改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，<br>无需switch,只需在对应的mutation函数里改变state值即可<br>（2）由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可<br>（3）Vuex数据流的顺序是:View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变(vue检测到数据变化自动渲染)</p>
<p>原文链接：<a href="https://blog.csdn.net/qq_42833001/article/details/89326428" target="_blank" rel="noopener">https://blog.csdn.net/qq_42833001/article/details/89326428</a></p>
<h3 id="实现一个简单的状态管理"><a href="#实现一个简单的状态管理" class="headerlink" title="实现一个简单的状态管理"></a>实现一个简单的状态管理</h3><p><a href="https://juejin.im/post/5cab4157e51d456e250004b0" target="_blank" rel="noopener">https://juejin.im/post/5cab4157e51d456e250004b0</a></p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><h3 id="父子组件如何进行通信"><a href="#父子组件如何进行通信" class="headerlink" title="父子组件如何进行通信"></a>父子组件如何进行通信</h3><p>父组件通过<code>props</code>的方式向子组件传递数据，而通过<code>$emit</code> 子组件可以向父组件通信。</p>
<p><code>$children</code>  /<code>$parent</code>。指定已创建的实例之父实例，在两者间建立父子关系。子实例可以用<code>this.$parent</code>访问父实例，子实例被推入父实例的<code>$children</code>数组中。（节制使用2. ,这个方法的主要目的是作为访问组件的应急方法。更推荐使用 1.）</p>
<p>上面两种方式用于父子组件之间的通信， 而使用props进行父子组件通信更加普遍; 二者皆不能用于非父子组件之间的通信。</p>
<p><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据。</p>
<p><code>provide</code>/ <code>inject</code> 是<code>vue2.2.0</code>新增的api, 简单来说就是父组件中通过<code>provide</code>来提供变量, 然后再子组件中通过<code>inject</code>来注入变量。<br>这里不论子组件嵌套有多深, 只要调用了<code>inject</code> 那么就可以注入<code>provide</code>中的数据，而不局限于只能从当前父组件的props属性中回去数据。</p>
<p><code>eventBus</code> 又称为事件总线，在vue中可以使用它来作为沟通桥梁的概念, 就像是所有组件共用相同的事件中心，可以向该中心注册发送事件或接收事件， 所以组件都可以通知其他组件。（eventBus也有不方便之处, 当项目较大,就容易造成难以维护的灾难。）</p>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化. Vuex 解决了<code>多个视图依赖于同一状态</code>和<code>来自不同视图的行为需要变更同一状态</code>的问题，将开发者的精力聚焦于数据的更新而不是数据在组件之间的传递上。</p>
<p>常见使用场景可以分为三类:</p>
<ul>
<li>父子组件通信: <code>props</code>; <code>$parent</code> / <code>$children</code>; <code>provide</code> / <code>inject</code> ; <code>ref</code> ;  <code>$attrs</code> / <code>$listeners</code></li>
<li>兄弟组件通信: <code>eventBus</code> ;     vuex</li>
<li>跨级通信:  <code>eventBus</code>；Vuex；<code>provide</code> / <code>inject</code> 、<code>$attrs</code> / <code>$listeners</code></li>
</ul>
<p>注意：provide和inject不是响应式的，这点很重要，除非申明的属性是响应式的！</p>
<p>作者：ikoala<br>链接：<a href="https://juejin.im/post/5d267dcdf265da1b957081a3" target="_blank" rel="noopener">https://juejin.im/post/5d267dcdf265da1b957081a3</a></p>
<h3 id="virtual-DOM是什么"><a href="#virtual-DOM是什么" class="headerlink" title="virtual DOM是什么"></a>virtual DOM是什么</h3><p>Virtual DOM 本质上是JavaScript对象，是对真实DOM的的一种描述方式。</p>
<h3 id="为什么需要-virtual-DOM"><a href="#为什么需要-virtual-DOM" class="headerlink" title="为什么需要 virtual DOM"></a>为什么需要 virtual DOM</h3><p> 和 DOM 操作比起来，js 计算是非常便宜的。Virtual DOM render + diff 显然比渲染 html 字符串要慢，但是，它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。</p>
<p>另外，DOM 完全不属于 Javascript (也不在 Javascript 引擎中存在).。Javascript 其实是一个非常独立的引擎，DOM 其实是浏览器引出的一组让 Javascript 操作 HTML 文档的 API 而已。在即时编译的时代，调用 DOM 的开销是很大的。而 Virtual DOM 的执行完全都在 Javascript 引擎中，完全不会有这个开销。</p>
<p> React.js 相对于直接操作原生 DOM 有很大的性能优势， 很大程度上都要归功于 virtual DOM 的 <strong>batching</strong> 和 <strong>diff</strong>。batching 把所有的 DOM 操作搜集起来，一次性提交给真实的 DOM。diff 算法时间复杂度也从<a href="http://grfia.dlsi.ua.es/ml/algorithms/references/editsurvey_bille.pdf" target="_blank" rel="noopener">标准的的 Diff 算法</a>的 O(n^3) 降到了 O(n)。</p>
<p> React 从来没有说过 “React 比原生操作 DOM 快”。React 给我们的保证是，在不需要手动优化的情况下，它依然可以给我们提供过得去的性能。</p>
<p> <strong>补充知识</strong>：React 掩盖了底层的 DOM 操作，可以用更声明式的方式来描述我们目的，从而让代码更容易维护。下面还是借鉴了知乎上的回答：没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark，我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。</p>
<p>转载自AlloyTeam：<a href="http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/" target="_blank" rel="noopener">http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/</a></p>
<h3 id="Vue-的-virtual-DOM解决了什么问题"><a href="#Vue-的-virtual-DOM解决了什么问题" class="headerlink" title="Vue 的 virtual DOM解决了什么问题"></a>Vue 的 virtual DOM解决了什么问题</h3><p>在Vue的底层实现上，Vue将模板编译成虚拟DOM渲染函数。结合Vue自带的响应系统，在状态改变时，Vue能够智能地计算出重新渲染组件的最小代价并应到DOM操作上。</p>
<p>总结下来就是</p>
<ol>
<li>组件的高度抽象化</li>
<li>可以更好的实现 SSR，同构渲染等</li>
<li>框架跨平台</li>
</ol>
<h2 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h2><h3 id="介绍一下-Vue-的-diff-策略"><a href="#介绍一下-Vue-的-diff-策略" class="headerlink" title="介绍一下 Vue 的 diff 策略"></a>介绍一下 Vue 的 diff 策略</h3><p>Vue的diff算法是基于snabbdom改造过来的，<strong>仅在同级的vnode间做diff，递归地进行同级vnode的diff，最终实现整个DOM树的更新</strong>。因为跨层级的操作是非常少的，忽略不计，这样时间复杂度就从O(n3)变成O(n)。</p>
<p>diff 算法包括几个步骤：</p>
<ul>
<li>用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中</li>
<li>当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异</li>
<li>把所记录的差异应用到所构建的真正的DOM树上，视图就更新了。</li>
</ul>
<p>diff 算法本身非常复杂，实现难度很大。有两个核心函数：</p>
<ul>
<li>patch(container,vnode)  :初次渲染的时候，将Virtual Dom渲染成真正的DOM然后插入到容器</li>
<li>patch(vnode,newVnode):再次渲染的时候，将新的vnode和旧的vnode相对比，然后之间差异应用到所构建的真正的DOM树上。</li>
</ul>
<p>作者：浪里行舟<br>链接：<a href="https://juejin.im/post/5d12c931f265da1bb2773fcc" target="_blank" rel="noopener">https://juejin.im/post/5d12c931f265da1bb2773fcc</a></p>
<p>###介绍一下 React 的 diff 策略</p>
<blockquote>
<p>计算一棵树形结构转换成另一棵树形结构的最少操作，是一个复杂且值得研究的问题。</p>
</blockquote>
<p>传统 diff 算法通过循环递归对节点进行依次对比，效率低下，算法复杂度达到 O(n^3)，其中 n 是树中节点的总数。O(n^3) 到底有多可怕，这意味着如果要展示1000个节点，就要依次执行上十亿次的比较。代价太高。</p>
<h4 id="diff策略"><a href="#diff策略" class="headerlink" title="diff策略"></a>diff策略</h4><ul>
<li>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计。</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。</li>
<li>对于同一层级的一组子节点，它们可以通过唯一 id 进行区分。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>React 通过分层求异的策略，对 tree diff 进行算法优化；</li>
<li>React 通过相同类生成相似树形结构，不同类生成不同树形结构的策略，对 component diff 进行算法优化；</li>
<li>React 通过设置唯一 key的策略，对 element diff 进行算法优化；</li>
<li>React 通过制定大胆的 diff 策略，将 O(n3) 复杂度的问题转换成 O(n) 复杂度的问题；</li>
<li>建议，开发时<strong>保持稳定的DOM结构</strong>有助于性能的提升.</li>
</ul>
<p>作者：Pivot<br>链接：<a href="https://juejin.im/post/5b3658f0518825522609e4c0" target="_blank" rel="noopener">https://juejin.im/post/5b3658f0518825522609e4c0</a></p>
<h3 id="Vue-的-diff-策略和-React-的-diff-策略有什么不同"><a href="#Vue-的-diff-策略和-React-的-diff-策略有什么不同" class="headerlink" title="Vue 的 diff 策略和 React 的 diff 策略有什么不同"></a>Vue 的 diff 策略和 React 的 diff 策略有什么不同</h3><p><strong>React 的 diff</strong>： </p>
<p>tree diff、component diff 和 element diff</p>
<p><strong>Vue 的 diff</strong>：</p>
<p>跟react一样，只进行同层级比较，忽略跨级操作patch。<br>diff时调用patch函数，patch接收两个参数<code>vnode，oldVnode</code>，分别代表新旧节点。即便同一个节点元素比如div，他的<code>className</code>不同，Vue就认为是两个不同类型的节点，执行删除旧节点、插入新节点操作。这与react diff实现是不同的，react对于同一个节点元素认为是同一类型节点，只更新其节点上的属性。<br>patchVnode：对于同类型节点调用<code>patchVnode(oldVnode, vnode)</code>进一步比较。<br><code>patchVnode</code>中有一个重要的概念updateChildren，这是Vue diff实现的<strong>核心</strong>。</p>
<p>作者：娘娘羌<br>链接：<a href="https://www.jianshu.com/p/398e63dc1969" target="_blank" rel="noopener">https://www.jianshu.com/p/398e63dc1969</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="key-有什么用"><a href="#key-有什么用" class="headerlink" title="key 有什么用"></a>key 有什么用</h3><p> 同一层级的一组节点，他们可以通过唯一的id进行区分。</p>
<h2 id="Vue-computed-watch"><a href="#Vue-computed-watch" class="headerlink" title="Vue computed/watch"></a>Vue computed/watch</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>当模板中的某个值需要通过一个或多个数据计算得到时，就可以使用计算属性，还有计算属性的函数不接受参数。</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>监听属性主要是监听某个值发生变化后，对新值去进行逻辑处理。</p>
<h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><p>React为什么要搞一个Hooks？</p>
<p>想要复用一个有状态的组件太麻烦了！</p>
<p>我们都知道react都核心思想就是，将一个页面拆成一堆独立的，可复用的组件，并且用自上而下的单向数据流的形式将这些组件串联起来。但假如你在大型的工作项目中用react，你会发现你的项目中实际上很多react组件冗长且难以复用。尤其是那些写成class的组件，它们本身包含了状态（state），所以复用这类组件就变得很麻烦。</p>
<p>那之前，官方推荐怎么解决这个问题呢？答案是：<a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">渲染属性（Render Props）</a>和<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">高阶组件（Higher-Order Components）</a>。但我们仔细看这两种模式，会发现它们会增加我们代码的层级关系。最直观的体现，打开devtool看看你的组件层级嵌套是不是很夸张吧。这时候再回过头看我们上一节给出的hooks例子，是不是简洁多了，没有多余的层级嵌套。把各种想要的功能写成一个一个可复用的自定义hook，当你的组件想用什么功能时，直接在组件里调用这个hook即可。</p>
<p>作者：zach5078<br>链接：<a href="https://juejin.im/post/5be3ea136fb9a049f9121014" target="_blank" rel="noopener">https://juejin.im/post/5be3ea136fb9a049f9121014</a></p>
<h2 id="Vue-和-React-有什么不同"><a href="#Vue-和-React-有什么不同" class="headerlink" title="Vue 和 React 有什么不同"></a>Vue 和 React 有什么不同</h2><p><strong>Vue 的好处</strong>：</p>
<ol>
<li>模板或渲染的灵活选项</li>
<li>语法以及项目设置的简单</li>
<li>渲染速度更快，体积更小</li>
</ol>
<p><strong>React 的好处</strong>：</p>
<ol>
<li>更大的规模、更多的使用者、更好的可测试性</li>
<li>Web和原生APP</li>
<li>能提供更多支持和工具的更大的生态系统</li>
</ol>
<p>React和Vue都是优秀的UI库，并且具有更多的<strong>相似之处</strong>。它们都有的优势是：</p>
<ul>
<li>使用虚拟DOM快速渲染</li>
<li>轻量级</li>
<li>响应式组件</li>
<li>服务端渲染</li>
<li>轻松集成的的路由、捆绑和状态管理</li>
<li>强大的支持和社区</li>
</ul>
<h1 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h1><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="常见的状态码有哪些"><a href="#常见的状态码有哪些" class="headerlink" title="常见的状态码有哪些"></a>常见的状态码有哪些</h3><p><img src="https://i.loli.net/2020/05/13/E27WJxAH4qaLrN1.png" srcset="/img/loading.gif" alt="image-20200513111202198"></p>
<p><a href="https://segmentfault.com/a/1190000005338367" target="_blank" rel="noopener">「理解HTTP」之常见的状态码</a></p>
<p><a href="https://juejin.im/post/5d5b72f1f265da03d21140ff" target="_blank" rel="noopener">常见的http状态码</a> 这个比上面的简略 但好像比较准，上面的可能太高级我还没懂，或者有错误。</p>
<h3 id="304表示什么，和302有什么区别"><a href="#304表示什么，和302有什么区别" class="headerlink" title="304表示什么，和302有什么区别"></a>304表示什么，和302有什么区别</h3><h4 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h4><p>临时性重定向。该状态码表示请求的资源已被分配了新的URI，希望用户本次能使用新的URI访问。<br>和301 Moved Permanently 状态码相似，但302状态码代表的资源不是被永久移动，只是临时性质的。<br>如果，用户把一个URI收藏为书签，302响应是不会像301那样去更新书签。</p>
<h4 id="304-Not-Modified"><a href="#304-Not-Modified" class="headerlink" title="304 Not Modified"></a>304 Not Modified</h4><p> 资源缓存，表示客户端发送的请求被允许，但是请求的内容没有改变.</p>
<h3 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h3><h4 id="介绍一下-http缓存"><a href="#介绍一下-http缓存" class="headerlink" title="介绍一下 http缓存"></a>介绍一下 http缓存</h4><p>缓存是一种保存资源副本并在下次请求时直接使用该副本的技术。当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。这样带来的好处有：缓解服务器端压力，提升性能(获取资源的耗时更短了)。对于网站来说，缓存是达到高性能的重要组成部分。缓存需要合理配置，因为并不是所有资源都是永久不变的：重要的是对一个资源的缓存应截止到其下一次发生改变（即不能缓存过期的资源）。</p>
<p>缓存的种类有很多,其大致可归为两类：私有与共享缓存。共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。本文将主要介绍浏览器与代理缓存，除此之外还有网关缓存、CDN、反向代理缓存和负载均衡器等部署在服务器上的缓存方式，为站点和 web 应用提供更好的稳定性、性能和扩展性。</p>
<p><img src="https://i.loli.net/2020/05/13/1JeGXhSbKZIQzqi.png" srcset="/img/loading.gif" alt="image-20200513113719613"></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存</a></p>
<h4 id="http-缓存策略"><a href="#http-缓存策略" class="headerlink" title="http 缓存策略"></a>http 缓存策略</h4><p>HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，将其分为两大类(强制缓存，对比缓存)。</p>
<p>强制缓存如果生效，不需要再和服务器发生交互，而对比缓存不管是否生效，都需要与服务端发生交互。<br>两类缓存规则可以同时存在，强制缓存优先级高于对比缓存，也就是说，当执行强制缓存的规则时，如果缓存生效，直接使用缓存，不再执行对比缓存规则。</p>
<p>在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，缓存规则信息包含在响应header中。对于强制缓存来说，响应header中会有两个字段来标明失效规则（Expires/Cache-Control）使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况。</p>
<p><strong>总结</strong>：<br>对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。<br>对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。</p>
<p><a href="https://www.cnblogs.com/chenqf/p/6386163.html" target="_blank" rel="noopener">彻底弄懂HTTP缓存机制及原理</a> 示意图画的很清楚</p>
<h3 id="Connection-为-keep-allive-表示什么"><a href="#Connection-为-keep-allive-表示什么" class="headerlink" title="Connection 为 keep-allive 表示什么"></a>Connection 为 keep-allive 表示什么</h3><p>HTTP协议采用请求-应答模式，有普通的非KeepAlive模式，也有KeepAlive模式。</p>
<p>非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能<strong>避免了建立或者重新建立连接</strong>。</p>
<p>不同版本 http默认keep-alive的启闭是不同的，现在的基本默认开。开的好处是性能提升，错误处理更优雅。为了得到这个好处要做一些数据接收的处理，使得客户可以判断请求所得到的响应数据是否已经接收完成。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Keep-Alive" target="_blank" rel="noopener">keep-alive|MDN</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/34052073" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34052073</a></p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS（Domain Name System，域名系统），因特网上作为<strong>域名和IP地址相互映射</strong>的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。</p>
<p>原文链接：<a href="https://blog.csdn.net/zhu_tianwei/article/details/45023461" target="_blank" rel="noopener">https://blog.csdn.net/zhu_tianwei/article/details/45023461</a></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一种面向连接的单播协议，在发送数据前，通信双方必须在彼此间建立一条连接。所谓的“连接”，其实是客户端和服务器的内存里保存的一份关于对方的信息，如ip地址、端口号等。</p>
<p>TCP可以看成是一种字节流，它会处理IP层或以下的层的丢包、重复以及错误问题。在连接的建立过程中，双方需要交换一些连接的参数。这些参数可以放在TCP头部。</p>
<p>TCP提供了一种可靠、面向连接、字节流、传输层的服务，采用三次握手建立一个连接。采用4次挥手来关闭一个连接。</p>
<p>ACK: acknowledge    RST: reset        SYN: synchronize    FIN: finish</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ol>
<li>客户端发送一个SYN段，并指明客户端的初始序列号，即ISN(c).</li>
<li>服务端发送自己的SYN段作为应答，同样指明自己的ISN(s)。为了确认客户端的SYN，将ISN(c)+1作为ACK数值。这样，每发送一个SYN，序列号就会加1. 如果有丢失的情况，则会重传。</li>
<li>为了确认服务器端的SYN，客户端将ISN(s)+1作为返回的ACK数值。</li>
</ol>
<h3 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h3><ol>
<li>客户端发送一个FIN段，并包含一个希望接收者看到的自己当前的序列号K. 同时还包含一个ACK表示确认对方最近一次发过来的数据。 </li>
<li>服务端将K值加1作为ACK序号值，表明收到了上一个包。这时上层的应用程序会被告知另一端发起了关闭操作，通常这将引起应用程序发起自己的关闭操作。</li>
<li>服务端发起自己的FIN段，ACK=K+1, Seq=L</li>
<li>客户端确认。ACK=L+1</li>
</ol>
<h3 id="为什么连三闭四"><a href="#为什么连三闭四" class="headerlink" title="为什么连三闭四"></a>为什么连三闭四</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
<p><a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">三次握手，四次挥手</a> 牛逼啊！</p>
<h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>HTTP：是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>HTTPS：是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>HTTPS协议的主要作用可以分为两种：一种是建立一个信息安全通道，来保证数据传输的安全；另一种就是确认网站的真实性。</p>
<p>###HTTPS 和 HTTP 有什么区别</p>
<p>HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。<br>简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。</p>
<p>HTTPS和HTTP的区别主要如下：</p>
<p>1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</p>
<p>2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</p>
<p>3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</p>
<p>4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p>
<p><a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">https://juejin.im/entry/58d7635e5c497d0057fae036</a></p>
<h3 id="介绍一下-HTTPS-的工作原理"><a href="#介绍一下-HTTPS-的工作原理" class="headerlink" title="介绍一下 HTTPS 的工作原理"></a>介绍一下 HTTPS 的工作原理</h3><p>1.Client发起一个HTTPS的<strong>请求</strong>，根据RFC2818的规定，Client需要连接Server的443（默认）端口。</p>
<p>2.Server把事先配置好的<strong>公钥证书</strong>（public key certificate）返回给客户端。</p>
<p>3.Client<strong>验证公钥证书</strong>：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。</p>
<p>4.Client使用伪随机数生成器<strong>生成</strong>加密所使用的<strong>对称密钥</strong>，然后<strong>用证书的公钥加密</strong>这个对称密钥，发给Server。</p>
<p>5.Server<strong>使用自己的私钥（private key）解密</strong>这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</p>
<p>6.Server<strong>使用对称密钥加密“明文内容A”</strong>，发送给Client。</p>
<p>7.Client<strong>使用对称密钥解密响应的密文</strong>，得到“明文内容A”。</p>
<p>8.Client<strong>再次</strong>发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。</p>
<p>作者：浪里行舟<br>链接：<a href="https://juejin.im/post/5ca6a109e51d4544e27e3048" target="_blank" rel="noopener">https://juejin.im/post/5ca6a109e51d4544e27e3048</a></p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><h3 id="介绍一下CDN是什么以及它的应用场景"><a href="#介绍一下CDN是什么以及它的应用场景" class="headerlink" title="介绍一下CDN是什么以及它的应用场景"></a>介绍一下CDN是什么以及它的应用场景</h3><p>CDN全称:Content Delivery Network或Content Ddistribute Network，即内容分发网络</p>
<h4 id="CDN设计思路"><a href="#CDN设计思路" class="headerlink" title="CDN设计思路"></a>CDN设计思路</h4><p><strong>避让</strong>：尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。<br><strong>检测</strong>：通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时监测网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求。<br><strong>分发</strong>：根据监测情况重新导向离用户最近的服务节点上。</p>
<h4 id="CDN-应用场景"><a href="#CDN-应用场景" class="headerlink" title="CDN 应用场景"></a>CDN 应用场景</h4><ol>
<li>网站站点/应用加速</li>
<li>视音频点播/大文件下载分发加速</li>
<li>视频直播加速</li>
</ol>
<p><a href="https://segmentfault.com/a/1190000015458489" target="_blank" rel="noopener">CDN简介</a> <a href="https://cloud.tencent.com/developer/news/251542" target="_blank" rel="noopener">另外一个</a></p>
<h3 id="CDN的回源是什么"><a href="#CDN的回源是什么" class="headerlink" title="CDN的回源是什么"></a>CDN的回源是什么</h3><p>当 cdn 缓存服务器中没有符合客户端要求的资源的时候，缓存服务器会请求上一级缓存服务器，以此类推，直到获取到。最后如果还是没有，就会回到我们自己的服务器去获取资源。 那都有哪些时候会回源呢？没有资源，资源过期，访问的资源是不缓存资源等都会导致回源。</p>
<p><a href="https://www.jianshu.com/p/eb974c412399" target="_blank" rel="noopener">动态CDN加速</a></p>
<h2 id="URL到页面展示，发生了什么"><a href="#URL到页面展示，发生了什么" class="headerlink" title="URL到页面展示，发生了什么"></a>URL到页面展示，发生了什么</h2><p><a href="https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/" target="_blank" rel="noopener">https://blog.fundebug.com/2019/02/28/what-happens-from-url-to-webpage/</a></p>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="介绍一下-栈，队列，链表"><a href="#介绍一下-栈，队列，链表" class="headerlink" title="介绍一下 栈，队列，链表"></a>介绍一下 栈，队列，链表</h2><h2 id="用-JavaScript-实现栈-队列-链表"><a href="#用-JavaScript-实现栈-队列-链表" class="headerlink" title="用 JavaScript 实现栈/队列/链表"></a>用 JavaScript 实现栈/队列/链表</h2><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h1 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h1><h1 id="另外"><a href="#另外" class="headerlink" title="另外"></a>另外</h1><p>Ajax,jQuery ajax,axios和fetch的区别<br>Ajax：<br>       ajax自然不必说，最早出现的发送后端请求技术，隶属于原始js中，核心使用XMLHttpRequest对象，多个请求之间如果有先后关系的话，就会出现回调地狱。<br>Jquery Ajax：<br>      是jQuery框架中的发送后端请求技术，由于jQuery是基于原始的基础上做的封装，所以，jquery Ajax自然也是原始ajax的封装<br>Fetch：<br>     fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多了，参数有点像jQuery ajax。但是，一定记住fetch不是ajax的进一步封装，而是原生js。Fetch函数就是原生js，没有使用XMLHttpRequest对象。<br>axios：<br>    axios不是原生JS的，需要进行安装，它不带可以在客户端使用，也可以在nodejs端使用。Axios也可以在请求和响应阶段进行拦截。同样也是基于promise对象的。具体参照axios的概念</p>
<p>CSDN博主「田江」<br>原文链接：<a href="https://blog.csdn.net/jiang7701037/article/details/79717310" target="_blank" rel="noopener">https://blog.csdn.net/jiang7701037/article/details/79717310</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "JavaScript 基础&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>


















<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true}});</script></body>
</html>
